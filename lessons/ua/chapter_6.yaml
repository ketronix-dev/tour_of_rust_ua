- title: Розділ 6 - Текст
  content_markdown: >
    Зараз, коли ми вже трошки розуміємо, як Rust взаємодіє з пам'яттю, ми 
    готові детальніше поговорити про текст.

    Rust звертає особливу увагу на проблеми з кількістю байтів, які
    використовуються для представлення тексту різними мовами. Ви можете бути не
    
    знайомі з подібними проблемами у інших мовах. Тим не менш, Rust має багато
    чудових інструментів для їх вирішення. 
- title: Рядкові літерали
  content_markdown: >
    Рядкові літерали завжди представлені у Unicode.  


    Тип рядкових літералів - `&'static str`:


    * `&` значить, що він посилається на певне місце у пам'яті, відсутність 
    `&mut` значить, що компілятор не дозволить робити зміни

    * `'static` значить, що цей рядок даних буде доступним до самого кінця 
    виконання нашої програми (він ніколи не видалиться)

    * `str` означає, що він вказує на послідовність байтів, які завжди будуть 
    дійсні у **utf-8**


    Деталі роботи з пам'яттю:

    * Компілятор Rust найімовірніше покладе ваш рядок у сегмент пам'яті, де 
    зберігаються дані вашої  програми
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20%22hi%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20a.len())%3B%0A%7D%0A
- title: Що таке utf-8
  content_markdown: "Чим більше мов використовувалось при роботі з комп'ютером, тим потрібніше світу було мати змогу\nвідображати більше символів ніж дозволяв ASCII( 1 байт міг передавати тільки 256 різних символів)\n\n**utf-8** була представлена зі змінною кількістю у 1-4 байтів. Це сильно збільшило діапазон доступних символів.\n\nПеревага змінного розміру символів це те, що текст не містить зайвих байтів для простих символів з  ASCII( у **utf-8** вони так само потребують 1 байт).\n\nЗворотньою стороною змінного розміру символів є те, що пошук символів більше не може бути швидким\n(**O(1)** константний час) за допомогю простого індексування (наприклад `my_text[3]` для отримання 4 символу). Цілком\nможливо, що попередні символи можуть мати змінну ширину, змінюючи місце фактичного початку 4 символу в послідовності байтів.\n\nНатомість ми повинні пройти через послідовність байтів utf-8, щоб зрозуміти, де насправді починаються символи Unicode (O(n) лінійний час).\n\nФерріс: \"Я просто щасливий, що маю utf-8 для використання емодзі, що зображують моїх підводних друзів.\"\n\n<span class=\"emoji\">\U0001F420\U0001F419\U0001F41F\U0001F42C\U0001F40B</span>\n" 
- title: Екранування символів
  content_markdown: >
    Візуально представити певні символи складно, тому екранування дозволяє
    нам розмістити символ у потрібному місці.


    Rust підтримує типові екрановані символи з С-подібних мов:

    * `\n` - перехід на новий рядок

    * `\r` - повернення каретки

    * `\t` - табуляція

    * `\\` - зворотній слеш

    * `\0` - нуль

    * `\'` - одинарні лапки


    Повний список знаходиться
    [тут](https://doc.rust-lang.org/reference/tokens.html).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26%27static%20str%20%3D%20%22Ferris%20says%3A%5Ct%5C%22hello%5C%22%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Ca)%3B%0A%7D%0A
- title: Багаторядкові рядкові літерали
  content_markdown: |
    Текст у Rust є багаторядковим за замовчуванням.

    Ви можете використовувати `\` у кінці рядка, якщо ви не хочете щоб він був перенесений на інший.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20haiku%3A%20%26'static%20str%20%3D%20%22%0A%20%20%20%20%20%20%20%20I%20write%2C%20erase%2C%20rewrite%0A%20%20%20%20%20%20%20%20Erase%20again%2C%20and%20then%0A%20%20%20%20%20%20%20%20A%20poppy%20blooms.%0A%20%20%20%20%20%20%20%20-%20Katsushika%20Hokusai%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20haiku)%3B%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20println!(%22hello%20%5C%0A%20%20%20%20world%22)%20%2F%2F%20notice%20that%20the%20spacing%20before%20w%20is%20ignored%0A%7D%0A
- title: Необроблені рядкові літерали
  content_markdown: >
    Raw strings allow us to write a sequence of characters verbatim by starting
    with `r#"` and ending with `"#`. It lets us insert

    characters that might otherwise confuse a normal string as literals (like
    double quotes and backslashes).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20r%23%22%0A%20%20%20%20%20%20%20%20%3Cdiv%20class%3D%22advice%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20Raw%20strings%20are%20useful%20for%20some%20situations.%0A%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%22%23%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D%0A
- title: String Literals From Files
  content_markdown: >
    If you have some very large text, consider using the macro `include_str!` to
    include text from local files in your program:


    ```rust

    let hello_html = include_str!("hello.html");

    ```
- title: String Slice
  content_markdown: >
    A string slice is a reference to a sequence of bytes in memory that must
    always be valid utf-8.


    A string slice (a sub-slice) of a `str` slice, must also be valid utf-8.


    Common methods of `&str`:

    * `len` gets the length of the string literal in bytes (not number of
    characters).

    *  `starts_with`/`ends_with` for basic testing.

    * `is_empty` returns true if zero length.

    * `find` returns an `Option<usize>` of the first position of some text.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20%22hi%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a.len())%3B%0A%20%20%20%20let%20first_word%20%3D%20%26a%5B0..2%5D%3B%0A%20%20%20%20let%20second_word%20%3D%20%26a%5B3..7%5D%3B%0A%20%20%20%20%2F%2F%20let%20half_crab%20%3D%20%26a%5B3..5%5D%3B%20FAILS%0A%20%20%20%20%2F%2F%20Rust%20does%20not%20accept%20slices%20of%20invalid%20unicode%20characters%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20first_word%2C%20second_word)%3B%0A%7D%0A
- title: Chars
  content_markdown: >
    With so much difficulty in working with Unicode, Rust offers a way to
    retrieve a sequence of utf-8 bytes as a vector of characters of type `char`.


    A `char` is always 4 bytes long (allowing for efficient lookup of individual
    characters).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20collect%20the%20characters%20as%20a%20vector%20of%20char%0A%20%20%20%20let%20chars%20%3D%20%22hi%20%F0%9F%A6%80%22.chars().collect%3A%3A%3CVec%3Cchar%3E%3E()%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars.len())%3B%20%2F%2F%20should%20be%204%0A%20%20%20%20%2F%2F%20since%20chars%20are%204%20bytes%20we%20can%20convert%20to%20u32%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars%5B3%5D%20as%20u32)%3B%0A%7D%0A
- title: String
  content_markdown: >
    A **String** is a struct that owns a sequence of utf-8 bytes in heap memory.


    Because its memory is on the heap, it can be extended, modified, etc. in
    ways string literals cannot.


    Common methods:


    * `push_str` to add more utf-8 bytes to the end of a string.

    * `replace` to replace sequences of utf-8 bytes with others.

    * `to_lowercase`/`to_uppercase` for case changes.

    * `trim` for trimming space


    When a String is dropped, its heap memory is also dropped.


    `String` has a `+` operator that extends the string with a `&str` and
    returns itself, but it might not be as ergonomic as you hope for.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20helloworld%20%3D%20String%3A%3Afrom(%22hello%22)%3B%0A%20%20%20%20helloworld.push_str(%22%20world%22)%3B%0A%20%20%20%20helloworld%20%3D%20helloworld%20%2B%20%22!%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%7D%0A
- title: Text As Function Parameters
  content_markdown: >
    String literals and strings are generally passed around as a string slice to
    functions. This offers a lot of flexibility for

    most scenarios where you don't actually have to pass ownership.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20say_it_loud(msg%3A%26str)%7B%0A%20%20%20%20println!(%22%7B%7D!!!%22%2Cmsg.to_string().to_uppercase())%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20say_it_loud%20can%20borrow%20%26%27static%20str%20as%20a%20%26str%0A%20%20%20%20say_it_loud(%22hello%22)%3B%0A%20%20%20%20%2F%2F%20say_it_loud%20can%20also%20borrow%20String%20as%20a%20%26str%0A%20%20%20%20say_it_loud(%26String%3A%3Afrom(%22goodbye%22))%3B%0A%7D%0A
- title: Building Strings
  content_markdown: |
    `concat` and `join` are two simple but powerful ways for building strings.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20helloworld%20%3D%20%5B%22hello%22%2C%20%22%20%22%2C%20%22world%22%2C%20%22!%22%5D.concat()%3B%0A%20%20%20%20let%20abc%20%3D%20%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D.join(%22%2C%22)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cabc)%3B%0A%7D%0A
- title: Formatting Strings
  content_markdown: >
    The `format!` macro allows us to create a string by defining a parameterized
    string with placeholders for where and how values should be placed (e.g.
    `{}`).


    `format!` uses the same parameterized strings as `println!`


    The capabilities of this function are too large of scope for *Tour of Rust*;
    check out the documentation [here](https://doc.rust-lang.org/std/fmt/).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20format!(%22secret%20to%20life%3A%20%7B%7D%22%2Ca)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cf)%3B%0A%7D%0A
- title: Converting Strings
  content_markdown: |
    Many types can be converted to a string using `to_string`.

    The generic function `parse` can be used to convert strings 
    or string literals into a typed value. This function returns 
    a `Result` because it could fail.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20-%3E%20Result%3C()%2C%20std%3A%3Anum%3A%3AParseIntError%3E%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20a_string%20%3D%20a.to_string()%3B%0A%20%20%20%20let%20b%20%3D%20a_string.parse%3A%3A%3Ci32%3E()%3F%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
- title: Chapter 6 - Conclusion
  content_markdown: >
    Now you know the basics of text!  As you have seen, Unicode makes working
    with text a bit tricky, but the standard library 

    has plenty of functionality to make it easy to manage.  


    Up to now, we've mostly looked at Rust from the lens of a procedural
    paradigm (i.e. just functions and data),

    but it's time we now talk about traits and the capabilities unlocked by
    Rust's object oriented paradigm.
