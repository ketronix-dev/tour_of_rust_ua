- title: Розділ 8 - Розумні покажчики (Smart Pointers)
  content_markdown: >
    У цьому розділі ми демістифікуємо розумні покажчики. Давайте 
    
    досліджувати ці структури даних, які дозволяють нам взаємодіяти 
    
    з найнижчим рівнем пам'яті.


    Ферріс каже: «Не бентежтеся через цей розділ, якщо ви не відчуваєте, що

    здатні написати власний низькорівневий код для керування пам’яттю за 
    одне коротке читання. Цей розділ 

     здебільшого познайомити вас із деякими корисними інструментами та дати 
     уявлення про те, як вони працюють!"
- title: Про посилання
  content_markdown: >
    По суті, посилання - це просто число, яке є стартовою позицією певних

    байтів у пам'яті. Його єдина мета - дати уявлення, де знаходиться данні  

    конкретного типу. Посилання відрізняється від звичайного числа тим, що Rust
    перевіряє, чи час життя посилання

    відповідає часу життя того, на що воно посилається (інакше ми отримали

    б повідомлення про помилку, під час використання!).
- title: Необробленні покажчики (Raw Pointers)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20memory_location%20%3D%20%26a%20as%20*const%20i32%20as%20usize%3B%0A%20%20%20%20println!(%22Data%20is%20here%20%7B%7D%22%2C%20memory_location)%3B%0A%7D%0A
  content_markdown: >
    Посилання можна перетворити у більш примітивний тип, який називається
    *необробленні покажчики*. Так само, як і числа їх

    можна копіювати і переміщувати з невеликими обмеженнями. Rust не

    гарантує існування місця у пам'яті на які вони вказують.


    Існує 2 види необроблених покажчиків:


    * `*const T` - необроблений покажчик на дані типу T, які ніколи не зміняться.

    * `*mut T` - необроблений покажчик на дані типу T, які можуть змінюватися.


    Необроблені покажчики можна перетворювати на числа та з них (наприклад, `usize`).

    Необроблені покажчики можуть отримати доступ до даних за допомогою *небезпечного* 
    коду (детальніше про це пізніше).

    Деталі про роботу з пам'яттю:

    * Посилання в Rust дуже схоже на покажчик у C з точки зору використання, 
    але з набагато більшими обмеженнями часу компіляції по тому, 
      як його можна зберігати та переміщувати до інших функцій.
    * Необроблений вказівник у Rust схожий на вказівник у C, оскільки він представляє число,
      яке можна копіювати або передавати, і навіть перетворювати на числові типи, де його 
      можна модифікувати як число для виконання математики вказівника.
- title: Розіменування
  content_markdown: |
    Процес доступу/управління даними, на які посилаються
    за *посиланням* (тобто `&i32`) називається *розіменуванням*.

    Посилання використовуються для доступу/управління даними двома способами:
    * Доступ до зазначених даних під час призначення змінних.
    * Доступ до полів або методів зазначених даних.
    
    У Rust є кілька потужних операторів, які дозволяють нам це робити.
- title: Оператор *
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20i32%20%3D%2042%3B%0A%20%20%20%20let%20ref_ref_ref_a%3A%20%26%26%26i32%20%3D%20%26%26%26a%3B%0A%20%20%20%20let%20ref_a%3A%20%26i32%20%3D%20**ref_ref_ref_a%3B%0A%20%20%20%20let%20b%3A%20i32%20%3D%20*ref_a%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20b)%0A%7D
  content_markdown: >
    Оператор * є явним способом для розіменування посилання.

    ```rust

    let a: i32 = 42;

    let ref_ref_ref_a: &&&i32 = &&&a;

    let ref_a: &i32 = **ref_ref_ref_a;

    let b: i32 = *ref_a;

    ```


    Деталі про роботу з пам'яттю:

    - Оскільки i32 є примітивним типом, який реалізує властивість `Copy`,

    байти змінної `a` у стеку копіюються в байти змінної
    `b`.
- title: Оператор .
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20value%3A%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20f%20%3D%20Foo%20%7B%20value%3A%2042%20%7D%3B%0A%20%20%20%20let%20ref_ref_ref_f%20%3D%20%26%26%26f%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20ref_ref_ref_f.value)%3B%0A%7D
  content_markdown: >
    Оператор `.` використовується для доступу до полів і методів посилання. Це
    працює дещо тонше.


    ```rust

    let f = Foo { value: 42 };

    let ref_ref_ref_f = &&&f;

    println!("{}", ref_ref_ref_f.value);

    ```

    Ого, а чому ми не додали `***` перед `ref_ref_ref_f`? Це тому, що
    оператор `.` автоматично роздиференціює 

    послідовність посилань. Останній рядок автоматично перетворюється 
    компілятором.


    ```rust

    println!("{}", (***ref_ref_ref_f).value);

    ```
- title: Розумні вказівники (Smart Pointers)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aops%3A%3ADeref%3B%0Astruct%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20value%3A%20T%2C%0A%7D%0Aimpl%3CT%3E%20Deref%20for%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20type%20Target%20%3D%20T%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26T%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20was%20used!%22%2C%20std%3A%3Aany%3A%3Atype_name%3A%3A%3CT%3E())%3B%0A%20%20%20%20%20%20%20%20%26self.value%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20TattleTell%20%7B%0A%20%20%20%20%20%20%20%20value%3A%20%22secret%20message%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%2F%2F%20dereference%20occurs%20here%20immediately%20%0A%20%20%20%20%2F%2F%20after%20foo%20is%20auto-referenced%20for%20the%0A%20%20%20%20%2F%2F%20function%20%60len%60%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.len())%3B%0A%7D%0A
  content_markdown: >
    На додаток до можливості створювати посилання на існуючі типізовані дані за допомогою
    оператора `&`, Rust надає нам можливість

    створювати *посилання-подібні* структури, які називаються **розумні вказівники**. 


    Ми можемо думати про посилання на високому рівні як про тип, який надає нам доступ до
    іншого типу. Розумні покажчики відрізняються за своєю 

    поведінкою від звичайних посилань тим, що вони працюють на основі внутрішньої логіки
    яку пише програміст. Ви - програміст -

    є *розумною* частиною.


    Зазвичай, розумні покажчики реалізують ознаки `Deref`, `DerefMut` та `Drop` для
    визначення логіки того, що має відбуватись, коли

    структуру розіменовують операторами `*` та `.`.
- title: Розумний небезпечний код (Smart Unsafe Code)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%5Bu8%3B%204%5D%20%3D%20%5B86%2C%2014%2C%2073%2C%2064%5D%3B%0A%20%20%20%20%2F%2F%20this%20is%20a%20raw%20pointer.%20Getting%20the%20memory%20address%0A%20%20%20%20%2F%2F%20of%20something%20as%20a%20number%20is%20totally%20safe%0A%20%20%20%20let%20pointer_a%20%3D%20%26a%20as%20*const%20u8%20as%20usize%3B%0A%20%20%20%20println!(%22Data%20memory%20location%3A%20%7B%7D%22%2C%20pointer_a)%3B%0A%20%20%20%20%2F%2F%20Turning%20our%20number%20into%20a%20raw%20pointer%20to%20a%20f32%20is%0A%20%20%20%20%2F%2F%20also%20safe%20to%20do.%0A%20%20%20%20let%20pointer_b%20%3D%20pointer_a%20as%20*const%20f32%3B%0A%20%20%20%20let%20b%20%3D%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20is%20unsafe%20because%20we%20are%20telling%20the%20compiler%0A%20%20%20%20%20%20%20%20%2F%2F%20to%20assume%20our%20pointer%20is%20a%20valid%20f32%20and%0A%20%20%20%20%20%20%20%20%2F%2F%20dereference%20it's%20value%20into%20the%20variable%20b.%0A%20%20%20%20%20%20%20%20%2F%2F%20Rust%20has%20no%20way%20to%20verify%20this%20assumption%20is%20true.%0A%20%20%20%20%20%20%20%20*pointer_b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22I%20swear%20this%20is%20a%20pie!%20%7B%7D%22%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    Розумні вказівники досить часто використовують *небезпечний* код. Як згадувалося
    раніше, 

    вони є поширеним інструментом для взаємодії з найнижчими рівнями пам'яті у
    Rust.


    Що таке небезпечний код? Небезпечний код поводиться так само, як і звичайний код у Rust, за
    за винятком декількох можливостей,

    щодо яких компілятор Rust не може надати гарантій.


    Основною можливістю небезпечного коду є *розіменування необроблених вказівник*. Це
    означає розміщення *необробленого вказівника* 

    в пам'яті та оголошення "тут існує структура даних!" і перетворення її на 
    дані, яке ви можете використовувати (наприклад, `*const u8` на
    `u8`). 

    Rust не має можливості відстежувати значення кожного байта, який записується
    до пам'яті. Оскільки, Rust не може надати 

    гарантій щодо того, чи існує щось за довільним номером, який використовується як *неороблений вказівник*,
    він поміщає розіменування у `unsafe { ... }` блок. 


    Розумні вказівники широко використовуються для *розіменування сирі вказівники*, і вони добре
    зарекомендували себе у тому, що вони роблять.
- title: Наші старі друзі
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aalloc%3A%3A%7Balloc%2C%20Layout%7D%3B%0Ause%20std%3A%3Aops%3A%3ADeref%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20secret_recipe%3A%20usize%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20new()%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20let's%20ask%20for%204%20bytes%0A%20%20%20%20%20%20%20%20let%20layout%20%3D%20Layout%3A%3Afrom_size_align(4%2C%201).unwrap()%3B%0A%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20allocate%20and%20save%20the%20memory%20location%20as%20a%20number%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20ptr%20%3D%20alloc(layout)%20as%20*mut%20u8%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20use%20pointer%20math%20and%20write%20a%20few%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20u8%20values%20to%20memory%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.write(86)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(1).write(14)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(2).write(73)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(3).write(64)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20Pie%20%7B%20secret_recipe%3A%20ptr%20as%20usize%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0Aimpl%20Deref%20for%20Pie%20%7B%0A%20%20%20%20type%20Target%20%3D%20f32%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26f32%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20interpret%20secret_recipe%20pointer%20as%20a%20f32%20raw%20pointer%0A%20%20%20%20%20%20%20%20let%20pointer%20%3D%20self.secret_recipe%20as%20*const%20f32%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20dereference%20it%20into%20a%20return%20value%20%26f32%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20%26*pointer%20%7D%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20p%20%3D%20Pie%3A%3Anew()%3B%0A%20%20%20%20%2F%2F%20%22make%20a%20pie%22%20by%20dereferencing%20our%20%0A%20%20%20%20%2F%2F%20Pie%20struct%20smart%20pointer%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20*p)%3B%0A%7D%0A
  content_markdown: >
    Розглянемо деякі розумні покажчики, які ми вже бачили, такі як `Vec<T>` та `String`.


    `Vec<T>` - це розумний покажчик, який просто володіє деякою областю пам'яті у байтах.
    Компілятор Rust не має жодного уявлення про те, що 

    знаходиться у цих байтах. Розумний вказівник інтерпретує, тобто захоплює
    елементи з області пам'яті, якою він керує,

    відстежує, де починаються і де закінчуються структури даних у цих байтах, і
    потім нарешті розіменовує необроблений вказівник

    на структури даних з гарним чистим і лаконічним інтерфейсом, якими ми можемо користуватися
    (наприклад, `my_vec[3]`).


    Аналогічно, `String` відстежує область пам'яті у байтах, і
    програмно обмежує вміст, що записується до неї, щоб завжди

    бути коректною у кодуванні `utf-8` і допомагає розіменовувати цю ділянку пам'яті до типу
    `&str`.


    Обидві ці структури даних використовують небезпечне розіменування необроблених вказівників для виконання
    вказівників для виконання своєї роботи.


    Подробиці про роботу з пам'ятю:

    * У Rust є еквівалент функції `malloc` у C за допомогою
    [alloc](https://doc.rust-lang.org/std/alloc/fn.alloc.html) та
    [Layout](https://doc.rust-lang.org/std/alloc/struct.Layout.html ) для
    отримання доступу до ваших власних областей пам'яті для подальшого керування.
- title: Пам'ять у купі (Heap Allocated Memory)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%7D%0A
  content_markdown: >
    `Box`- це розумний вказівник, який дозволяє переміщувати дані зі стеку до купи.


    Його розіменування дозволяє нам ергономічно використовувати дані, виділені у купі, так, ніби вони
    були оригінальним типом.
- title: Обробка помилок функції main
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Afmt%3A%3ADisplay%3B%0Ause%20std%3A%3Aerror%3A%3AError%3B%0A%0Astruct%20Pie%3B%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20NotFreshError%3B%0A%0Aimpl%20Display%20for%20NotFreshError%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20std%3A%3Afmt%3A%3AFormatter%3C%27_%3E)%20-%3E%20std%3A%3Afmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20write!(f%2C%20%22This%20pie%20is%20not%20fresh!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20Error%20for%20NotFreshError%20%7B%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20Err(Box%3A%3Anew(NotFreshError))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3F%3B%0A%20%20%20%20Ok(())%0A%7D%0A
  content_markdown: >
    Код Rust може мати безліч представлень помилок, але стандартна
    бібліотека має

    універсальну конструкцію `std::error::Error` для опису помилок.


    Використовуючи розумні покажчик `Box`, ми можемо використовувати тип `Box<dyn std::error::Error>`
    як загальний тип для повернення помилок, оскільки він дозволяє нам

    поширювати помилку у купі та взаємодіяти з нею на високому рівні
    без необхідності знати конкретний тип.


    На початку туру по Rust ми дізналися, що `main` може повертати помилку. Тепер ми можемо
    повертати

    тип, здатний описати майже будь-який тип помилки, що може виникнути у
    у нашій програмі, 

    якщо структура даних помилки реалізує загальну для Rust
    властивість `Error`.


    ```rust

    fn main() -> Result<(), Box<dyn std::error:Error>>

    ```
- title: Лічильник посилань
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Rc%3A%3Anew(Pie)%3B%0A%20%20%20%20let%20heap_pie2%20%3D%20heap_pie.clone()%3B%0A%20%20%20%20let%20heap_pie3%20%3D%20heap_pie2.clone()%3B%0A%0A%20%20%20%20heap_pie3.eat()%3B%0A%20%20%20%20heap_pie2.eat()%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%0A%20%20%20%20%2F%2F%20all%20reference%20count%20smart%20pointers%20are%20dropped%20now%0A%20%20%20%20%2F%2F%20the%20heap%20data%20Pie%20finally%20deallocates%0A%7D%0A
  content_markdown: >
    `Rc` - це розумний покажчик, який переміщує дані зі стеку в купу. Він
    дозволяє нам 

    клонувати інші розумні вказівники `Rc`, які мають можливість незмінно
    запозичувати дані, 

    які було поміщено на купу не змінюючи їх.


    Тільки коли останній розумний покажчик буде скинуто, дані  будуть
    викинуті з купи.
- title: Спільний доступ
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20RefCell%20validates%20memory%20safety%20at%20runtime%0A%20%20%20%20%2F%2F%20notice%3A%20pie_cell%20is%20not%20mut!%0A%20%20%20%20let%20pie_cell%20%3D%20RefCell%3A%3Anew(Pie%7Bslices%3A8%7D)%3B%0A%20%20%20%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20we%20can%20borrow%20mutable%20references!%0A%20%20%20%20%20%20%20%20let%20mut%20mut_ref_pie%20%3D%20pie_cell.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20mut_ref_pie.eat()%3B%0A%20%20%20%20%20%20%20%20mut_ref_pie.eat()%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%2F%2F%20mut_ref_pie%20is%20dropped%20at%20end%20of%20scope%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20now%20we%20can%20borrow%20immutably%20once%20our%20mutable%20reference%20drops%0A%20%20%20%20%20let%20ref_pie%20%3D%20pie_cell.borrow()%3B%0A%20%20%20%20%20println!(%22%7B%7D%20slices%20left%22%2Cref_pie.slices)%3B%0A%7D%0A
  content_markdown: >
    `RefCell` - це контейнерна структура даних, яка зазвичай утримується розумними покажчиками,
    яка приймає дані і дозволяє нам

    змінювати змінні та незмінні посилання на те, що знаходиться всередині. Це запобігає
    зловживанню 
    
    запозиченнями, використовуючи правила безпеки пам'яті Rust, коли ви робите запит
    запозичити

    дані всередині:


    **Тільки одного змінюваного посилання АБО декількох незмінних посилань, але не
    обох видів одночасно! **.


    Якщо ви порушите ці правила, `RefCell` впаде у паніку.
- title: Спільне доступ до даних у різних потоках
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Async%3A%3AMutex%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22only%20I%20eat%20the%20pie%20right%20now!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mutex_pie%20%3D%20Mutex%3A%3Anew(Pie)%3B%0A%20%20%20%20%2F%2F%20let's%20borrow%20a%20locked%20immutable%20reference%20of%20pie%0A%20%20%20%20%2F%2F%20we%20have%20to%20unwrap%20the%20result%20of%20a%20lock%0A%20%20%20%20%2F%2F%20because%20it%20might%20fail%0A%20%20%20%20let%20ref_pie%20%3D%20mutex_pie.lock().unwrap()%3B%0A%20%20%20%20ref_pie.eat()%3B%0A%20%20%20%20%2F%2F%20locked%20reference%20drops%20here%2C%20and%20mutex%20protected%20value%20can%20be%20used%20by%20someone%20else%0A%7D%0A
  content_markdown: >
    `Mutex` - це контейнерна структура даних, яку зазвичай утримують розумні вказівники, що
    приймає дані і дозволяє нам замінювати змінювані

    та незмінні посилання на дані всередині. Це запобігає зловживанню 
    запозиченням 

    коли операційна система обмежує лише одному потоку процесора
    доступ до даних, 

    блокуючи інші потоки, доки початковий потік не завершить роботу із заблокованим
    запозичення.


    Багатопоточність виходить за рамки Tour of Rust, але `Mutex` є
    фундаментальною частиною організації

    декількох потоків процесора, які отримують доступ до одних і тих самих даних.


    Існує спеціальний розумний покажчик `Arc`, який ідентичний `Rc`, за винятком того, що
    використовує безпечне для потоків інкрементування лічильників посилань. 

    Його часто використовують для того, щоб мати багато посилань на один і той самий `Mutex`.
- title: Поєднання розумних покажчиків
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0Ause%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat_slice(%26mut%20self%2C%20name%3A%20%26str)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20took%20a%20slice!%22%2C%20name)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20pie%3A%20Rc%3CRefCell%3CPie%3E%3E%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20use%20smart%20pointer%20to%20pie%20for%20a%20mutable%20borrow%0A%20%20%20%20%20%20%20%20let%20mut%20p%20%3D%20self.pie.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20take%20a%20bite!%0A%20%20%20%20%20%20%20%20p.eat_slice(%26self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20pie%20%3D%20Rc%3A%3Anew(RefCell%3A%3Anew(Pie%20%7B%20slices%3A%208%20%7D))%3B%0A%20%20%20%20%2F%2F%20ferris%20and%20sarah%20are%20given%20clones%20of%20smart%20pointer%20to%20pie%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22ferris%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22sarah%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20ferris.eat()%3B%0A%20%20%20%20sarah.eat()%3B%0A%0A%20%20%20%20let%20p%20%3D%20pie.borrow()%3B%0A%20%20%20%20println!(%22%7B%7D%20slices%20left%22%2C%20p.slices)%3B%0A%7D%0A
  content_markdown: >
    Розумні покажчики можуть здатися обмеженими, але вони можуть створювати дуже потужні
    комбінації.


    `Rc<Vec<Foo>>` - Дозволяє клонування декількох смарт-покажчиків, які можуть
    позичати один і той самий вектор незмінних структур даних на купі.


    `Rc<RefCell<Foo>>` - Дозволити декільком смарт-покажчикам запозичувати
    взаємно/незмінно одну й ту саму структуру `Foo`.


    `Arc<Mutex<Foo>>` - Дозволяє декільком смарт-покажчикам блокувати
    тимчасові змінювані/незмінні запозичення виключно для потоку процесора.


    Деталі роботи за памяттю:

    * Використання незмінного типу даних (який може належати декільком смарт-покажчикам) для модифікації
    внутрішніх даних у Rust називається патерном "внутрішня змінюваність". Це патерн, який дозволяє нам змінювати правила використання пам'яті під час виконання з тим же рівнем безпеки, що і перевірки Rust під час компіляції.

- title: Розділ 8 - Висновок
  content_markdown: >
    Розумні покажчики - це ідіома програмування на Rust, і нам не доведеться
    повторно створювати дуже поширені патерни використання пам'яті.

    Тепер, коли ми ознайомилися з основами Rust, давайте трохи поговоримо про те
    як створювати більші проекти. У главі 9 ми перестанемо писати код у одному файлі.
