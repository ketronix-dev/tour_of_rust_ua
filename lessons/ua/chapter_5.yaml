- title: Розділ 5 - Володіння та позичання
  content_markdown: >
    Rust має унікальну парадигму керування пам'яттю у порівнянні з іншими мовами
    програмування . Ми розглянемо

    поведінку та валідації компілятора по черзі, щоб не
    перевантажувати. Важливо пам'ятати, що 

    правила, які ми показуємо, існують не для того, щоб ускладнити вам життя, а для
    того, щоб допомогти
    зробити ваш код краще!
- title: Володіння
  content_markdown: >
    Створення екземпляру типу та **зв'язування** його з іменем змінної створює ресурс
    пам'яті
    ресурс пам'яті, який компілятор Rust буде перевіряти

    протягом усього його **життя**.  Прив'язана змінна називається
    **власником** ресурсу, тобто вона **володіє** ним.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20We%20instantiate%20structs%20and%20bind%20to%20variables%0A%20%20%20%20%2F%2F%20to%20create%20memory%20resources%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20is%20the%20owner%0A%7D%0A
- title: Управління даними на основі розміру.
  content_markdown: |
    Rust використовує кінець області видимості як місце для деконструкції та
    перерозподілу ресурсу.

    Термін для такої деконструкції та вивільнення називається **drop (скидання)**.

    Деталі роботи за памяттю:
    * У Rust не передбачено збирання сміття через і без того гарний менеджмент
    пам'яті.
    * У C++ це також називається "Отримання ресурсу є ініціалізацією"
    (Resource Acquisition Is Initialization, RAII).
  code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2013%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20%2F%2F%20foo_b%20is%20dropped%20here%20%0A%20%20%20%20%2F%2F%20foo_a%20is%20dropped%20here%0A%7D%0A
- title: Видалення відбувається по іерархії
  content_markdown: >
    Якщо ви видаляте якусь структуру, то спочатку видаляється сама структура,
    а потім дочірні елементи, потім дочірні дочірніх. Тобто зверху вниз.


    Деталі роботи за памяттю:

    * При автоматичному вивільненні пам'яті, Rust зробить все, щоб
    не відбулося витоків пам'яті.

    * Ресурс пам'яті можна звільнити лише 1 раз.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Bar%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Astruct%20Foo%20%7B%0A%20%20%20%20bar%3A%20Bar%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20bar%3A%20Bar%20%7B%20x%3A%2042%20%7D%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.bar.x)%3B%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20first%0A%20%20%20%20%2F%2F%20then%20foo.bar%20is%20dropped%0A%7D%0A
- title: Передача володіння
  content_markdown: >
    Коли власник передає дані як аргумент у функцію, то до аргументу також
    переходить право власності.


    Після передачі володіння, минолого власника (тобто наприклад змінну)
    використовувати не можна, через те що володіння передано іншому власнику.


    Деталі роботи за памяттю:

    * Під час **переміщення** пам'ять власника копіюється до пам'яті параметра
    у пам'ять параметрів виклику функції.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20is%20moved%20to%20do_something%0A%20%20%20%20do_something(foo)%3B%0A%20%20%20%20%2F%2F%20foo%20can%20no%20longer%20be%20used%0A%7D%0A
- title: Повернення володіння
  content_markdown: |
    При поверненнф значення з функції, повертається також і володіння.
    Тому володіння даними отримує той, хто прийме повернуті значення,
    будь то змінна, чи параметр іншої функції.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something()%20-%3E%20Foo%20%7B%0A%20%20%20%20Foo%20%7B%20x%3A%2042%20%7D%0A%20%20%20%20%2F%2F%20ownership%20is%20moved%20out%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20do_something()%3B%0A%20%20%20%20%2F%2F%20foo%20becomes%20the%20owner%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20because%20of%20end%20of%20function%20scope%0A%7D%0A
- title: Отримання володіння через посилання
  content_markdown: |
    Володіння також можна передати за допомогою посилання, для цього треба перед змінною
    поставити оператор `&`.

    Посилання видаляються з пам'яті так само як і будь-які інші ресурси даних.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26foo%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
- title: Отримання володіння через мутабельні посилання
  content_markdown: >
    Якщо ви хочете отримати володіння у мутабельному посиланні, то замість
    оператора `&` треба писати `&mut`.


    Ресурс не можна змінювати чи переміщувати, поки на нього вказує мутабельне посилання.


    Деталі роботи за памяттю:

    * Rust не дає можливості мати декілька мутабельних посилань, задля забезпечення цілістності даних.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%0A%20%20%20%20%2F%2F%20FAILURE%3A%20do_something(foo)%20would%20fail%20because%0A%20%20%20%20%2F%2F%20foo%20cannot%20be%20moved%20while%20mutably%20borrowed%0A%0A%20%20%20%20%2F%2F%20FAILURE%3A%20foo.x%20%3D%2013%3B%20would%20fail%20here%20because%0A%20%20%20%20%2F%2F%20foo%20is%20not%20modifiable%20while%20mutably%20borrowed%0A%0A%20%20%20%20f.x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%20because%20it's%20no%20longer%20used%20after%20this%20point%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.x)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20this%20works%20now%20because%20all%20mutable%20references%20were%20dropped%0A%20%20%20%20foo.x%20%3D%207%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20move%20foo's%20ownership%20to%20a%20function%0A%20%20%20%20do_something(foo)%3B%0A%7D%0A
- title: Розіменування посилань
  content_markdown: >
    Використовуючи `&mut` ви можете встановити значення ресурсу на котрий посилаються
    за допомогою оператора`*`.

    Щоб зкопіювати значення з ресурсу через посилання також можна використати оператор `*`
    (про копіювання данних різних типів ми поговоримо пізніше).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%20%20%20%20let%20bar%20%3D%20*f%3B%20%2F%2F%20get%20a%20copy%20of%20the%20owner's%20value%0A%20%20%20%20*f%20%3D%2013%3B%20%20%20%20%20%20%2F%2F%20set%20the%20reference's%20owner's%20value%0A%20%20%20%20println!(%22%7B%7D%22%2C%20bar)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo)%3B%0A%7D%0A
- title: Передача запозичених даних
  content_markdown: >
    Тепер можно коротко підсумувати правила використання посилань в Rust:


    * Rust дозволяє створювати лише одне мутабельне посилання на ресурс **або** декілька
    не мутабельних посилань, і ні в якому разі неможна мати **і ті і ті одночасно**.

    * Посилання не повинні **жити довше** ніж ресурс на котрий вони посилаються.


    Зазвичай це до речі не є проблемою, якщо посилання веде на функцію.


    Деталі роботи за памяттю:

    * Перше правило запобігає так званому "перегону даних", або якщо більш по людьськи - розсінхрону,
    таке відбувається якщо по двум різним посиланням одразу починають записувати данні. Зустрічається таке
    переважно в асінхронному програмувані.

    * Друге правило запобігає утворенню так званих "посилань-зомбі", котрі звертаються до вже не існуючих даних.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20%26mut%20Foo)%20%7B%0A%20%20%20%20f.x%20%2B%3D%201%3B%0A%20%20%20%20%2F%2F%20mutable%20reference%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20because%20all%20mutable%20references%20are%20dropped%20within%0A%20%20%20%20%2F%2F%20the%20function%20do_something,%20we%20can%20create%20another.%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
- title: Посилання на посилання
  content_markdown: |
    Посилання можна використовувати навіть у фрагментах посилань.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(a%3A%20%26Foo)%20-%3E%20%26i32%20%7B%0A%20%20%20%20return%20%26a.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%20allow%20us%20to%20create%20a%20non-mutable%20reference%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
- title: Явний час життя
  content_markdown: >
    Хоч компілятор вам цього не покаже, але він розуміє час життя кожної змінної.
    І саме це дає йому можливість аналізувати код, і сказати вам, чи буде
    посилання жити довше ніж сама змінна.
    
    Але ви також можете самостійно сказати якому ресурсу скільки жити.
    Для цього існують спеціальні параметри.

    Щоб виставити час життя, або якщо більш корректно - пріоритети
    , вам лише треба поставити символ `'`, а потім додати одну із латинських
    букв (наприклад `'a`, `'b`, `'c`)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20the%20parameter%20foo%20and%20return%20value%20share%20the%20same%20lifetime%0Afn%20do_something%3C'a%3E(foo%3A%20%26'a%20Foo)%20-%3E%20%26'a%20i32%20%7B%0A%20%20%20%20return%20%26foo.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%2C%20allowing%20us%20to%20create%20a%20non-mutable%20reference%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
- title: Кілька модифікаторів пріорітету
  content_markdown: >
    Модифікатори часу життя, або ж приорітету, дозволяють нам створювати 
    сценарії, котрі мають деякі відмінності від тих що за замовчуванням
    створює компілятор.

    Це досягається за допомогою використання декількох модифікаторів часу життя,
    а точніше, їх комбінування.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20foo_b%20and%20the%20return%20value%20share%20the%20same%20lifetime%0A%2F%2F%20foo_a%20has%20an%20unrelated%20lifetime%0Afn%20do_something%3C'a%2C%20'b%3E(foo_a%3A%20%26'a%20Foo%2C%20foo_b%3A%20%26'b%20Foo)%20-%3E%20%26'b%20i32%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20return%20%26foo_b.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2012%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20do_something(%26foo_a%2C%20%26foo_b)%3B%0A%20%20%20%20%2F%2F%20foo_a%20is%20dropped%20here%20because%20only%20foo_b's%20lifetime%20exist%20beyond%20here%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo_b%20is%20dropped%20here%0A%7D%0A
- title: Статичний час життя
  content_markdown: >
    Статичні змінні - це змінні котрі створюються на початку, або під час роботи програми, і
    існують до самого її кінця. Такі змінні повинні мати чітко вказані типи.
    
    Статичні ресурси можуть існувати невизначено довго, але лише до моменту
    вимкнення програми. Також треба зауважити що такі ресурси можуть бути створені
    прямо під час виконання програми.


    Статичні ресурси мають спеціальну позначку - `static`. Такі ресурси не будуть **видалятися**
    під час виконання програми, поки цього не захоче сам користувач.


    Якщо на ресурс є якісь посилання - вони повинні бути також статичними, інакше
    вони можуть не "прожити" потрібний період часу.


    Деталі роботи за памяттю:


    * Зміна статичних ресурсів є по суті небезпечною операцією, через те що
    вони доступні звідусіль, і таким чином там можуть відбутися так звані
    "перегони даних", при асинхроному записі, про проблеми глобальних даних
    ми поговоримо пізніше.
    * Rust дозволя використовувати `unsafe { ... }` блоки в тих місцях, де компілятор
    не може забеспечити гарантії безпечної роботи з пам'яттю. На [<span
    style="color:red; font-weight:
    bold;">R̸͉̟͈͔̄͛̾̇͜U̶͓͖͋̅Ṡ̴͉͇̃̉̀T̵̻̻͔̟͉́͆Ơ̷̥̟̳̓͝N̶̨̼̹̲͛Ö̵̝͉̖̏̾̔M̶̡̠̺̠̐͜Î̷̛͓̣̃̐̏C̸̥̤̭̏͛̎͜O̶̧͚͖͔̊͗̇͠N̸͇̰̏̏̽̃</span>](https://doc.rust-lang.org/nomicon/)
    ви можете прочитати про це більш детально.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=static%20PI%3A%20f64%20%3D%203.1415%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20static%20variables%20can%20also%20be%20scoped%20to%20a%20function%0A%20%20%20%20static%20mut%20SECRET%3A%20%26'static%20str%20%3D%20%22swordfish%22%3B%0A%0A%20%20%20%20%2F%2F%20string%20literals%20have%20a%20'static%20lifetime%0A%20%20%20%20let%20msg%3A%20%26'static%20str%20%3D%20%22Hello%20World!%22%3B%0A%20%20%20%20let%20p%3A%20%26'static%20f64%20%3D%20%26PI%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20msg%2C%20p)%3B%0A%0A%20%20%20%20%2F%2F%20You%20can%20break%20some%20rules%2C%20but%20you%20must%20be%20explicit%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20set%20SECRET%20to%20a%20string%20literal%20because%20it%20is%20also%20%60static%0A%20%20%20%20%20%20%20%20SECRET%20%3D%20%22abracadabra%22%3B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20SECRET)%3B%0A%20%20%20%20%7D%0A%7D%0A
- title: Час життя в типах даних
  content_markdown: >
    Подібно до функцій, типи даних можна параметризувати за допомогою специфікаторів часу життя
    специфікаторами часу життя його членів.


    Rust перевіряє, що структура даних, яка містить посилання, ніколи не існує довше, ніж власники, на яких вона посилається.


    Ми не можемо мати структури, які працюють з посиланнями, що вказують на
    неіснуючі дані!
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%3C'a%3E%20%7B%0A%20%20%20%20i%3A%26'a%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%0A%20%20%20%20%20%20%20%20i%3A%20%26x%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cfoo.i)%3B%0A%7D%0A
- title: Розділ 5 - Висновки
  content_markdown: >
    Вітаємо, ви впоралися! Я знаю, це важко прийняти, але ти

    на шляху до того, щоб стати Іржавцем (оріг. - Rustacean). Сподіваюся, тепер зрозуміло, що Rust як
    мова має на меті 

    вирішити багато з цих поширених проблем у системному програмуванні:


    * ненавмисна модифікація ресурсів

    * забути деконструювати ресурси 

    * випадкова деконструкція ресурсів двічі

    * використання ресурсів після їх деконструкції 

    * Перегони даних, спричинені записом до ресурсів у той час, коли інші читають з них

    * чітке бачення ділянок коду, де компілятор не може надати гарантій


    У наступному розділі ми застосуємо деякі з цих знань, розглядаючи, як
    Rust працює з текстом.
