- title: Розділ 9 - Організація проекту, та його структура
  content_markdown: >
    Ну що ж. До цього в усіх прикладах ви бачили код котрий був розташований
    лише в одному файлі. Зараз настав час, коли ми почнемо говорити про те
    як краще організувати свій код для того, щоб він став краще, і його було
    легше зрозуміти іншим!
- title: Модулі
  content_markdown: |
    Будь яка програма чи бібліотека на Rust є *crate* (це такі пакети в rust).

    Кожен crate створює ієрархію *модулів*.

    Кожен crate є головним модулем.

    Модулі можуть мати в собі як глобальні змінні, так і структури, функції, трейти, і т.д.!

    У Rust немає відображення файлів до ієрархії дерева модулів 1 до 1. Ми повинні будувати дерево модулів явно вручну в нашому коді.
- title: Написання програм
  content_markdown: |
    Ваша програма є головним модулем у файлі під назвою `main.rs`.
- title: Написання бібліотеки
  content_markdown: |
    Ваша бібліотека є головним модулем у файлі під назвою `lib.rs`.
- title: Зсилання на crate та модулі
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%22)%3B%0A%20%20%20%20println!(%22I%20would%20love%20a%20slice%20of%20%7B%7D!%22%2C%20PI)%3B%0A%7D%0A
  content_markdown: >
    Елемент із модуля доступний лише при вказування повного шляху до самого модуля
    `std::f64::consts::PI`.


    Але це можна спростити з використанням **use**. Це надасть вам можливість
    зробити код візуально краще, і ви зможете вказувати лише потрібну частину шляху

    без необхідності вказувати повний шлях. Наприклад `use
    std::f64::consts::PI`

    дозволить використовувати мені `PI` у моїх функціях.


    **std** це crate **стандартної бібліотеки** Rust, котра надає вам повну
    необхідну інформацію

    структури і функції для роботи з вашою операційною системою.


    А тут ви зможете знайти будь-який потрібний вам crate -
    [https://crates.io](https://crates.io/).
- title: Посилання на декілька елементів
  content_markdown: |
    Ви можете посилатися на декілька елементів одного і того самого модуля:

    ```rust
    use std::f64::consts::{PI,TAU}
    ```

    Якщо-що, то Ферріс їсть тільки PI, від TAU його нудить.
- title: Створення модулів
  content_markdown: |
    Коли ми думаємо про код, то зазвичай уявляємо собі ієрархію файлів, організованих
    у каталогах. Rust дозволяє створювати модулі, тісно пов'язані з вашою файловою
    структурою вашого файлу.

    У Rust є два способи оголошення модуля. Наприклад, модуль
    `foo` може бути представлений як:
      * файлу з іменем `foo.rs`.
      * директорія з іменем `foo` з файлом `mod.rs` всередині.
- title: Ієрархія модулів
  content_markdown: >
    Один модуль може залежати від іншого. Для того, щоб встановити зв'язок

    між модулем та його підмодулем, ви повинні написати у батьківському модулі


    ```rust

    mod foo;

    ```


    Наведений вище оголошення шукатиме файл з іменем `foo.rs` або `foo/mod.rs`.
    і

    вставить його вміст у модуль з іменем `foo` у цій області видимості.
- title: Вбудований модуль
  content_markdown: >
    Підмодуль може бути безпосередньо вбудований у код модуля.


    Одне з найпоширеніших застосувань вбудованих модулів - створення модульних тестів. Ми створюємо
    вбудований модуль, який існує лише тоді, коли для тестування використовується Rust!


    ```

    // Цей макрос видаляє цей вбудований модуль, коли Rust

    // не знаходиться в режимі тестування.

    #[cfg(test)]

    mod tests {
        // Зверніть увагу, що ми не одразу отримуємо доступ до
        // батьківського модуля. Ми повинні бути явними.
        використовуйте super::*;

        ... тести йдуть сюди ...
    }

    ```
- title: Внутрішнє посилання на модулі
  content_markdown: >
    У Rust є кілька ключових слів, які ви можете використовувати у шляху `use`, щоб швидко отримати доступ
    до потрібного вам модуля:
      
    * `crate` - Головний модуль вашого проекту.

    * `super` - батьківський модуль вашого модуля, тобто той що вище по ієрархії.

    * `self` - поточний модуль.
- title: Експорт
  content_markdown: >
    За замовчуванням члени *модуля* недоступні ззовні
    модуля (навіть з його дочірніх модулів!). Ми робимо члени

    модуля доступними за допомогою ключового слова `pub`.


    За замовчуванням члени *crate* недоступні ззовні цього crate. Ми
    робимо члени

    доступними, позначивши їх як `pub` у *кореневому модулі* вашого
    (`lib.rs` або `main.rs`).
- title: Видимість структури
  content_markdown: >
    Так само як і функції, структури можуть оголошувати те, що вони хочуть виходити за межі
    модуля за допомогою `pub`.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20SeaCreature%20struct%20will%20be%20usable%20outside%20of%20our%20module%0Apub%20struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20animal_type%3A%20String%2C%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20pub%20arms%3A%20i32%2C%0A%20%20%20%20pub%20legs%3A%20i32%2C%0A%20%20%20%20%2F%2F%20let's%20keep%20our%20weapon%20private%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A
- title: Прелюдія
  content_markdown: |
    Вам може бути цікаво, як ми маємо доступ до `Vec` або `Box`
    скрізь без використання `use` для їх імпорту. Це завдяки модулю
    `prelude` у стандартній бібліотеці.

    Знайте, що у стандартній бібліотеці Rust все, що експортується у
    `std::prelude::*`, автоматично стає доступним для кожної частини Rust.
    Це стосується як `Vec` і `Box`, так і інших (Option, Copy,
    тощо).
- title: Ваша особиста прелюдія
  content_markdown: >
    Оскільки прелюдія є стандартним компонентом бібліотеки, у вашій бібліотеці, як правило, є
    власний модуль прелюдії як відправна точка з котрої

    користувачі мають імпортувати усі найпоширеніші структури даних для використання
    вашої бібліотеки (наприклад, `use my_library::prelude::*`).

    Ферріс: "Будь добрим ракоподібним і допоможи крабу з гарною прелюдією!"
- title: Розділ 9 - Висновки
  content_markdown: >
    Тепер у вас є кілька хитрощів у рукаві, коли справа доходить до створення Rust-додатків і бібліотек
    , готових до публікації. Не турбуйтеся про те, щоб запам'ятати все це. У міру того, як ваша бібліотека
    зростатиме і нею користуватимуться інші ви зрозумієте, що найкраще працює на кожному етапі.


    Ресурси:

    - [Настанови з написання Rust
    API] (https://rust-lang.github.io/api-guidelines/)
